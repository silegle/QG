## 简答题

#### 1.DirectX和OpenGL中的纹理坐标系和屏幕坐标系有什么区别？

| DirectX纹理坐标系 | U轴都是水平朝右，V轴竖直向下      |
| ----------------- | --------------------------------- |
| DirectX屏幕坐标系 | x轴水平朝右，y轴竖直向下          |
| OpenGL纹理坐标系  | x轴水平朝右，y轴竖直向上，z轴向外 |
| OpenGL屏幕坐标系  | x轴水平朝右，y轴竖直向下          |

#### 2.Blinn-Phong光照模型相较于Phong模型做了什么改进？

- | 「环境光」(ambient lighting)：物体表面完全背对光源，但其它物体反射光照照射到该物体表面上，再通过该物体反射光照到人眼 | 认为是常量                                                   |
  | ------------------------------------------------------------ | ------------------------------------------------------------ |
  | 「漫反射光」(diffuse reflection)：物体朝着任意方向反射相同亮度的光照到人眼 | 认为在任何反射反向上的分布是一样的，漫反射的大小取决于表面法线与光线的夹角，夹角越大，漫反射分量 |
  | 「高光」(specular highlights)：物体完全反射光源照射到表面的光照到人眼 | 由于平面并非完全光滑，反射光并非只有R一个点，而是R周边的一小块区域，眼睛/摄像机离R越近，反射光照强度越大 |

  phong模型中认为，高光反射的强度与反射光线\*R\*和观察角度\*v\*之间夹角的余弦值成正比。需要去求向量v在R上的投影，也就需要去求R。

  计算反射光线R有点繁琐，Blinn-Phong提出了一个简单的修改方式：通过对向量l和向量v取平均然后归一化得到一个新的向量h，其中h被称为半程向量(bisector)，使用h与法线n点乘来计算高光，这样就可以避免计算R了。

#### 3.简述一下什么是各向异性过滤，相较于Mipmap有什么优点？

①Mipmap的缺点，它只能针对正方形纹理进行Mip分层，当透视效果越明显，越远处的像素对应纹理中的区域会越不接近正方形（更像长条的矩形，甚至连矩形都不是），如果使用面积更大的正方形来包住这个区域，此时的结果就会愈加不准确，造成了越远处越模糊的感觉。

②当几何图形进行纹理贴图时，如果它的观察方向和观察点怡好垂直，那么这个过程是相当完整的。当我们从一个角度倾斜地观察这个几何图形时，对周围纹理单元进行常规采样，会导致一些纹理信息丟失。为了更加逼真和准确的采样应该沿著包含纹理的平面方向进行延伸。如果我们进行处理纹理过滤时，考虑了观察角度，那么这个过滤方法就叫“各向异性过滤”

#### 4.纹理除了存储颜色信息还能存储什么？

从宏观角度来说，纹理就是一张图片；从微观角度来说，纹理是一种供着色器读写的结构化存储形式，即一个容器，类似于多维数组。

纹理并不局限于存储颜色信息，也可以存储高度信息、纹理通道、法线信息等。

## 实践题

#### 1.创建一个立方体，贴上纹理

①获取一份`jpg`文件，将其转化为dds格式，放到cmake编译后项目文件中Texture文件夹中

②在`GameApp.h`中声明指针，设置枚举类型

```
 ComPtr<ID3D11ShaderResourceView> m_pCubeCrate;			    // 立方体纹理
```

```
  enum class ShowMode {CubeCrate, FireAnim};
```

③在`GameApp::InitResource`中用`CreateDDSTextureFromFile`函数初始化stone纹理

```
  HR(CreateDDSTextureFromFile(m_pd3dDevice.Get(), L"..\\Texture\\stone.dds", nullptr, m_pCubeCrate.GetAddressOf()));
```

④GameApp::UpdateScene中更新画面

```

void GameApp::UpdateScene(float dt)
{
    if (ImGui::Begin("Texture Mapping"))
    {
        static int curr_mode_item = static_cast<int>(m_CurrMode);
        const char* mode_strs[] = {
            "Cube",
            "Fire Anim"
        };
        if (ImGui::Combo("Mode", &curr_mode_item, mode_strs, ARRAYSIZE(mode_strs)))
        {
            if (curr_mode_item == 0)
            {

                m_CurrMode = ShowMode::CubeCrate;
                m_pd3dImmediateContext->IASetInputLayout(m_pVertexLayout3D.Get());
                auto meshData = Geometry::CreateBox();
                ResetMesh(meshData);
                m_pd3dImmediateContext->VSSetShader(m_pVertexShader3D.Get(), nullptr, 0);
                m_pd3dImmediateContext->PSSetShader(m_pPixelShader3D.Get(), nullptr, 0);
                m_pd3dImmediateContext->PSSetShaderResources(0, 1, m_pCubeCrate.GetAddressOf());
            }
            else if(curr_mode_item==1)
            {
                m_CurrMode = ShowMode::FireAnim;
                m_CurrFrame = 0;
                m_pd3dImmediateContext->IASetInputLayout(m_pVertexLayout2D.Get());
                auto meshData = Geometry::Create2DShow();
                ResetMesh(meshData);
                m_pd3dImmediateContext->VSSetShader(m_pVertexShader2D.Get(), nullptr, 0);
                m_pd3dImmediateContext->PSSetShader(m_pPixelShader2D.Get(), nullptr, 0);
                m_pd3dImmediateContext->PSSetShaderResources(0, 1, m_pFireAnims[0].GetAddressOf());
            }
        }
    }
    ImGui::End();
    ImGui::Render();

    if (m_CurrMode == ShowMode::CubeCrate)
    {
        static float phi = 0.0f, theta = 0.0f;
        phi += 0.0001f, theta += 0.00015f;
        XMMATRIX W = XMMatrixRotationX(phi) * XMMatrixRotationY(theta);
        m_VSConstantBuffer.world = XMMatrixTranspose(W);
        m_VSConstantBuffer.worldInvTranspose = XMMatrixTranspose(InverseTranspose(W));

        // 更新常量缓冲区，让立方体转起来
        D3D11_MAPPED_SUBRESOURCE mappedData;
        HR(m_pd3dImmediateContext->Map(m_pConstantBuffers[0].Get(), 0, D3D11_MAP_WRITE_DISCARD, 0, &mappedData));
        memcpy_s(mappedData.pData, sizeof(VSConstantBuffer), &m_VSConstantBuffer, sizeof(VSConstantBuffer));
        m_pd3dImmediateContext->Unmap(m_pConstantBuffers[0].Get(), 0);
    }
    else if (m_CurrMode == ShowMode::FireAnim)
    {
        // 用于限制在1秒60帧
        static float totDeltaTime = 0;

        totDeltaTime += dt;
        if (totDeltaTime > 1.0f / 60)
        {
            totDeltaTime -= 1.0f / 60;
            m_CurrFrame = (m_CurrFrame + 1) % 120;
            m_pd3dImmediateContext->PSSetShaderResources(0, 1, m_pFireAnims[m_CurrFrame].GetAddressOf());
        }		
    }

}
```

⑤效果图

![屏幕截图 2024-04-06 180743](C:\Users\dmxxxx\Pictures\Screenshots\屏幕截图 2024-04-06 180743.png)

#### 2.使用不同的纹理过滤模式，观察区别

关于过滤器

图片放大**-->**空缺的像素位置需要选择合适的方式进行填充**-->**①常量插值法：对x和y都进行四舍五入的操作，然后取临近像素点的颜色**-->**②线性插值法：一维情况，已知第20个像素点的颜色`p0`和第21个像素点的颜色`p1`，并且经过拉伸放大后，有一个像素点落在范围`(20, 21)`之间，我们就可以使用线性插值法求出最终的颜色(t取`(0,1)`)：`p=tp1+(1−t)p0`

图片缩小-->需要抛弃一些像素-->d3d中使用mipmapping技术-->金字塔采样原理-->一张256x256的纹理，通过不断的向下采样，可以获得256x256、128x128、64x64...一直到1x1的一系列位图，这些位图构建了一条mipmap链，并且不同的纹理标注有不同的mipmap等级-->其中mipmap等级为0的纹理即为原来的纹理，等级为1的纹理所占内存为等级为0的1/4，等级为2的纹理所占内存为等级为1的1/4...以此类推我们可以知道包含完整mipmap的纹理占用的内存空间不超过原来纹理的4/3

点过滤(point filtering):选取mipmap等级对应图片和缩小后的图片大小最接近的一张，然后进行线性插值法或者常量插值法

线性过滤(linear filtering)：选取两张mipmap等级相邻的图片，使得缩小后的图片大小在那两张位图之间，然后对这两张位图进行常量插值法或者线性插值法分别取得颜色结果，最后对两个颜色结果进行线性插值法

`D3D11_FILTER`部分枚举含义如下：

| 枚举值                                      | 缩小     | 放大     | mipmap   |
| ------------------------------------------- | -------- | -------- | -------- |
| D3D11_FILTER_MIN_MAG_MIP_POINT              | 点采样   | 点采样   | 点采样   |
| D3D11_FILTER_MIN_MAG_POINT_MIP_LINEAR       | 点采样   | 点采样   | 线性采样 |
| D3D11_FILTER_MIN_POINT_MAG_LINEAR_MIP_POINT | 点采样   | 线性采样 | 点采样   |
| D3D11_FILTER_MIN_MAG_MIP_LINEAR             | 线性采样 | 线性采样 | 线性采样 |
| D3D11_FILTER_ANISOTROPIC                    | 各向异性 | 各向异性 | 各向异性 |

在`GameApp::InitResource()` 初始化采样器状态中设置过滤模式

```
sampDesc.Filter = D3D11_FILTER_ANISOTROPIC;
```

效果图：

![2792e0fc79e86dfcee5700af8c83eba](C:\Users\dmxxxx\Documents\WeChat Files\wxid_a2l3ybfy7qod22\FileStorage\Temp\2792e0fc79e86dfcee5700af8c83eba.png)



```
sampDesc.Filter =D3D11_FILTER_MIN_MAG_MIP_POINT;
```

效果图：

![d5ec580698c520050a74e6e0d611bc4](C:\Users\dmxxxx\Documents\WeChat Files\wxid_a2l3ybfy7qod22\FileStorage\Temp\d5ec580698c520050a74e6e0d611bc4.png)



#### 3.使用不同的纹理寻址模式，观察区别

`D3D11_TEXTURE_ADDRESS_MODE`是单个方向的寻址模式，有时候纹理坐标会超过1.0或者小于0.0，这时候寻址模式可以解释边界外的情况，含义如下：

| D3D11_TEXTURE_ADDRESS_WRAP        | 是将指定纹理坐标分量的值[t, t + 1], t ∈ Z映射到[0.0, 1.0]，因此作用到u和v分量时看起来就像是把用一张贴图紧密平铺到其他位置上 |
| --------------------------------- | ------------------------------------------------------------ |
| D3D11_TEXTURE_ADDRESS_MIRROR_ONCE | 相当于MIRROR和CLAMP的结合，仅[-1.0,1.0]的范围内镜像有效，若小于-1.0则取-1.0，大于1.0则取1.0，在[-1.0, 0.0]进行翻转。 |
| D3D11_TEXTURE_ADDRESS_MIRROR      | 在每个整数点处翻转纹理坐标值                                 |
| D3D11_TEXTURE_ADDRESS_CLAMP       | 指定纹理坐标分量，小于0.0的值都取作0.0，大于1.0的值都取作1.0，在[0.0, 1.0]的纹理坐标不变 |
| D3D11_TEXTURE_BORDER_COLOR        | 对于指定纹理坐标分量的值在[0.0, 1.0]外的区域都使用`BorderColor`进行填充 |

在`GameApp::InitResource()` 初始化采样器状态中设置寻址模式

```
sampDesc.AddressU = D3D11_TEXTURE_ADDRESS_WRAP;
sampDesc.AddressV = D3D11_TEXTURE_ADDRESS_WRAP;
sampDesc.AddressW = D3D11_TEXTURE_ADDRESS_WRAP;
```

效果图：

![84653be34daf00fb5a7ade10850bb28](C:\Users\dmxxxx\Documents\WeChat Files\wxid_a2l3ybfy7qod22\FileStorage\Temp\84653be34daf00fb5a7ade10850bb28.png)

```
sampDesc.AddressU =  D3D11_TEXTURE_ADDRESS_MIRROR_ONCE;
sampDesc.AddressV =  D3D11_TEXTURE_ADDRESS_MIRROR_ONCE;
sampDesc.AddressW =  D3D11_TEXTURE_ADDRESS_MIRROR_ONCE;
```

效果图：

![b366e9a78527d1832c0fa20f284a7c1](C:\Users\dmxxxx\Documents\WeChat Files\wxid_a2l3ybfy7qod22\FileStorage\Temp\b366e9a78527d1832c0fa20f284a7c1.png)

#### 4.让纹理旋转起来

①在`Basic_3D_VS.hlsl`中修改,让纹理坐标与旋转矩阵相乘

```
    vOut.tex = mul(float4(vIn.tex, 0.0f, 1.0f), g_WorldInvTranspose); 
```

②在GameApp.cpp中修改顶点常量缓冲区存入的数据

```
···
if (m_CurrMode == ShowMode::WoodCrate)
{
    static float phi = 0.0f, theta = 0.0f;
    phi += 0.0001f, theta += 0.00015f;
    XMMATRIX W = XMMatrixRotationX(phi) * XMMatrixRotationY(theta);
    m_VSConstantBuffer.world = XMMatrixTranspose(W);
    //修改
    static float alpha = 0.0f;
    alpha += 0.01f;//使纹理逆时针旋转
    XMMATRIX RotateMatrix = XMMatrixTranslation(-0.5f, -0.5f, 0.0f) * XMMatrixRotationZ(alpha) * XMMatrixTranslation(0.5f, 0.5f, 0.0f);
    m_VSConstantBuffer.worldInvTranspose = XMMatrixTranspose(RotateMatrix);
···    
```

③结果图



![屏幕截图 2024-04-06 203740](C:\Users\dmxxxx\Pictures\Screenshots\屏幕截图 2024-04-06 203740.png)